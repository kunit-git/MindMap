<!DOCTYPE html>
<html>
<head>
    <title>Mind Map Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        #header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        #header h1 {
            font-size: 28px;
            font-weight: 600;
            color: #667eea;
            margin-bottom: 5px;
        }

        #header p {
            color: #666;
            font-size: 14px;
        }

        #container {
            display: flex;
            gap: 20px;
            padding: 0 20px 20px 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        #controls {
            width: 250px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            height: fit-content;
            position: sticky;
            top: 20px;
        }

        #controls h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #667eea;
            font-weight: 600;
        }

        #mindmap {
            flex-grow: 1;
            display: block;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            min-height: 500px;
        }

        .node {
            padding: 10px 15px;
            margin: 8px 0;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            transition: all 0.2s ease;
            position: relative;
        }

        .node:hover {
            transform: translateX(2px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .leaf.new {
            background: linear-gradient(135deg, #e0e7ff 0%, #f0f4ff 100%);
            border-left: 4px solid #818cf8;
            color: #4c51bf;
        }

        .leaf.in-progress {
            background: linear-gradient(135deg, #fef3c7 0%, #fef9e7 100%);
            border-left: 4px solid #f59e0b;
            color: #92400e;
        }

        .leaf.done {
            background: linear-gradient(135deg, #d1fae5 0%, #ecfdf5 100%);
            border-left: 4px solid #10b981;
            color: #065f46;
        }

        .parent.new {
            background: linear-gradient(135deg, #f3e8ff 0%, #faf5ff 100%);
            border-left: 4px solid #a78bfa;
            color: #5b21b6;
            font-weight: 600;
        }

        .parent.in-progress {
            background: linear-gradient(135deg, #fed7aa 0%, #ffedd5 100%);
            border-left: 4px solid #fb923c;
            color: #9a3412;
            font-weight: 600;
        }

        .parent.done {
            background: linear-gradient(135deg, #6ee7b7 0%, #d1fae5 100%);
            border-left: 4px solid #059669;
            color: #064e3b;
            font-weight: 600;
        }

        .node-container {
            border: 2px solid transparent;
            padding: 8px;
            margin: 8px 0;
            border-radius: 10px;
            display: block;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.5);
        }

        .node-container:hover {
            background: rgba(255, 255, 255, 0.8);
        }

        .node-container.selected {
            border: 2px solid #667eea;
            background: rgba(102, 126, 234, 0.05);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .node-container.dragging {
            opacity: 0.6;
            transform: scale(0.98);
            background: rgba(102, 126, 234, 0.1);
        }

        .node-container.drag-over {
            border: 2px dashed #667eea;
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }

        button {
            margin: 8px 0;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            font-family: inherit;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        button:active {
            transform: translateY(0);
        }

        #controls button {
            width: 100%;
            box-sizing: border-box;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        #controls button:hover {
            background: linear-gradient(135deg, #5568d3 0%, #653a8b 100%);
        }

        .node button {
            padding: 4px 10px;
            font-size: 12px;
            background: rgba(255, 255, 255, 0.9);
            color: #666;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .node button:hover {
            background: white;
            color: #333;
            border-color: #667eea;
        }

        input[type="file"] {
            margin: 8px 0;
            padding: 10px;
            border: 2px dashed #667eea;
            border-radius: 8px;
            width: 100%;
            cursor: pointer;
            background: rgba(102, 126, 234, 0.05);
            font-size: 13px;
        }

        input[type="file"]:hover {
            background: rgba(102, 126, 234, 0.1);
            border-color: #5568d3;
        }

        select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid rgba(0,0,0,0.2);
            background: white;
            cursor: pointer;
            font-size: 13px;
            margin-left: 5px;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        select:hover {
            border-color: #667eea;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .completion-badge {
            background: rgba(255, 255, 255, 0.9);
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: auto;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }

        .modal-content {
            background: white;
            margin: 15% auto;
            padding: 30px;
            border-radius: 12px;
            max-width: 400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-content h3 {
            margin-bottom: 20px;
            color: #667eea;
            font-size: 20px;
        }

        .modal-content input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 20px;
            font-family: inherit;
        }

        .modal-content input:focus {
            outline: none;
            border-color: #667eea;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-buttons button {
            margin: 0;
            padding: 10px 20px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #666;
        }

        .btn-secondary:hover {
            background: #d0d0d0;
        }

        #helpSection {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid rgba(102, 126, 234, 0.2);
        }

        #helpSection h3 {
            font-size: 14px;
            color: #667eea;
            margin-bottom: 10px;
        }

        #helpSection ul {
            list-style: none;
            font-size: 12px;
            color: #666;
        }

        #helpSection li {
            padding: 4px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #helpSection li::before {
            content: "‚Üí";
            color: #667eea;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>üß† Mind Map Manager</h1>
        <p>Organize your ideas, track progress, and visualize your workflow</p>
    </div>

    <div id="container">
        <div id="controls">
            <h2>Controls</h2>
            <button onclick="addNode()">‚ûï Add Node</button>
            <button onclick="renameNode()">‚úèÔ∏è Rename Node</button>
            <button onclick="removeNode()">üóëÔ∏è Remove Node</button>
            <button onclick="exportToJson()">üíæ Export to JSON</button>
            <input type="file" id="importFile" accept=".json" onchange="importFromJson()" title="Import from JSON file">

            <div id="helpSection">
                <h3>üí° Quick Tips</h3>
                <ul>
                    <li>Click to select a node</li>
                    <li>Drag & drop to reorganize</li>
                    <li>Use +/- to collapse nodes</li>
                    <li>Track progress with status</li>
                </ul>
            </div>
        </div>
        <div id="mindmap"></div>
    </div>

    <!-- Modal for Add/Rename Node -->
    <div id="inputModal" class="modal">
        <div class="modal-content">
            <h3 id="modalTitle">Enter Node Name</h3>
            <input type="text" id="modalInput" placeholder="Node name...">
            <div class="modal-buttons">
                <button class="btn-secondary" onclick="closeModal()">Cancel</button>
                <button class="btn-primary" onclick="submitModal()">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Modal for Confirmation -->
    <div id="confirmModal" class="modal">
        <div class="modal-content">
            <h3 id="confirmTitle">Confirm Action</h3>
            <p id="confirmMessage"></p>
            <div class="modal-buttons">
                <button class="btn-secondary" onclick="closeConfirmModal()">Cancel</button>
                <button class="btn-primary" onclick="confirmAction()">Confirm</button>
            </div>
        </div>
    </div>

    <script>
        class Node {
            constructor(name, isLeaf = true, children = [], collapsed = false) {
                this.name = name;
                this.isLeaf = isLeaf;
                this.children = children;
                this.status = isLeaf ? 'new' : this.calculateStatus();
                this.collapsed = collapsed;
            }

            calculateStatus() {
                if (this.isLeaf) return this.status;
                if (!this.children.length) return 'new';
                
                const childStatuses = this.children.map(child => child.status);
                if (childStatuses.every(s => s === 'done')) return 'done';
                if (childStatuses.some(s => s === 'in-progress') || 
                    childStatuses.some(s => s === 'done')) return 'in-progress';
                return 'new';
            }

            calculateCompletionPercentage() {
                if (this.isLeaf) return this.status === 'done' ? 100 : 0;
                if (!this.children.length) return 0;
                
                let totalLeafNodes = 0;
                let completedLeafNodes = 0;
                
                function countLeafNodes(node) {
                    if (node.isLeaf) {
                        totalLeafNodes++;
                        if (node.status === 'done') completedLeafNodes++;
                    } else {
                        node.children.forEach(countLeafNodes);
                    }
                }
                
                countLeafNodes(this);
                return totalLeafNodes > 0 ? Math.round((completedLeafNodes / totalLeafNodes) * 100) : 0;
            }
        }

        let mindMap = new Node('Root', false);
        let selectedNode = null;
        let draggedNode = null;
        let modalCallback = null;
        let confirmCallback = null;

        function renderMindMap(node = mindMap, element = document.getElementById('mindmap'), depth = 0) {
            if (!element) {
                console.error('Mindmap element not found');
                return;
            }
            element.innerHTML = '';

            function createNodeElement(currentNode, currentDepth) {
                const container = document.createElement('div');
                container.className = 'node-container';
                container.draggable = true;
                container.dataset.nodeName = currentNode.name;
                if (currentNode === selectedNode) container.classList.add('selected');

                container.ondragstart = (e) => {
					e.stopPropagation();
					if (draggedNode) return; // ignore this event
                    draggedNode = currentNode;
                    container.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', currentNode.name);
                };

                container.ondragend = () => {
                    container.classList.remove('dragging');
                    draggedNode = null;
                    updateParentStatuses(mindMap);
                    renderMindMap();
                };

                container.ondragover = (e) => {
                    e.preventDefault();
                };

                container.ondragenter = (e) => {
                    e.preventDefault();
                    if (draggedNode && draggedNode !== currentNode) {
                        container.classList.add('drag-over');
                    }
                };

                container.ondragleave = () => {
                    container.classList.remove('drag-over');
                };

                container.ondrop = (e) => {
                    e.stopPropagation();
					e.preventDefault();
                    container.classList.remove('drag-over');
					console.log(draggedNode.name + " - " + currentNode.name);
                    if (draggedNode && draggedNode !== currentNode && draggedNode !== mindMap) {
                        // Find and remove draggedNode from its original parent
                        const originalParent = findParent(mindMap, draggedNode);
                        if (originalParent) {
                            const index = originalParent.children.indexOf(draggedNode);
                            if (index !== -1) {
                                originalParent.children.splice(index, 1);
                                if (originalParent.children.length === 0) {
                                    originalParent.isLeaf = true;
                                    originalParent.status = 'new';
                                }
                            }
                        }

                        // Attach draggedNode as a child of currentNode
                        if (currentNode.isLeaf) {
                            currentNode.isLeaf = false;
                            currentNode.status = 'new';
                        }
                        currentNode.children.push(draggedNode);

                        // Update statuses and re-render
                        updateParentStatuses(mindMap);
                        renderMindMap();
                    }
                };

                const nodeDiv = document.createElement('div');
                const completionPercentage = currentNode.calculateCompletionPercentage();
                nodeDiv.className = `node ${currentNode.isLeaf ? 'leaf' : 'parent'} ${currentNode.status}`;
                nodeDiv.style.marginLeft = `${currentDepth * 20}px`;

                const nodeName = document.createElement('span');
                nodeName.textContent = currentNode.name;
                nodeDiv.appendChild(nodeName);

                const badge = document.createElement('span');
                badge.className = 'completion-badge';
                badge.textContent = `${completionPercentage}%`;
                nodeDiv.appendChild(badge);

                nodeDiv.onclick = (e) => {
                    e.stopPropagation();
                    selectedNode = currentNode;
                    renderMindMap();
                };

                if (!currentNode.isLeaf && currentNode.children.length) {
                    const collapseBtn = document.createElement('button');
                    collapseBtn.textContent = currentNode.collapsed ? '+' : '-';
                    collapseBtn.style.marginLeft = '5px';
                    collapseBtn.onclick = (e) => {
                        e.stopPropagation();
                        currentNode.collapsed = !currentNode.collapsed;
                        renderMindMap();
                    };
                    nodeDiv.appendChild(collapseBtn);
                }

                const addChildBtn = document.createElement('button');
                addChildBtn.textContent = 'Remove';
                addChildBtn.style.marginLeft = '5px';
                addChildBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeChild(currentNode);
                    renderMindMap();
                };
                nodeDiv.appendChild(addChildBtn);                

                container.appendChild(nodeDiv);

                if (currentNode.isLeaf) {
                    const statusSelect = document.createElement('select');
                    ['new', 'in-progress', 'done'].forEach(status => {
                        const option = document.createElement('option');
                        option.value = status;
                        option.text = status;
                        if (status === currentNode.status) option.selected = true;
                        statusSelect.appendChild(option);
                    });
                    statusSelect.onchange = (e) => {
                        currentNode.status = e.target.value;
                        updateParentStatuses(mindMap);
                        renderMindMap();
                    };
                    statusSelect.style.marginLeft = `${currentDepth * 20 + 5}px`;
                    container.appendChild(statusSelect);
                }

                if (!currentNode.isLeaf && !currentNode.collapsed) {
                    currentNode.children.forEach(child => {
                        container.appendChild(createNodeElement(child, currentDepth + 1));
                    });
                }

                return container;
            }

            const rootElement = createNodeElement(node, depth);
            element.appendChild(rootElement);
        }

        function updateParentStatuses(node) {
            if (!node.isLeaf) {
                node.status = node.calculateStatus();
                node.children.forEach(child => updateParentStatuses(child));
            }
        }

        function findParent(root, target) {
            if (root.children.includes(target)) return root;
            for (let child of root.children) {
                const parent = findParent(child, target);
                if (parent) return parent;
            }
            return null;
        }

        function areSiblings(node1, node2) {
            const parent1 = findParent(mindMap, node1);
            const parent2 = findParent(mindMap, node2);
            return parent1 === parent2 && parent1 !== null;
        }

        // Modal helper functions
        function showModal(title, placeholder = '', defaultValue = '', callback) {
            const modal = document.getElementById('inputModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalInput = document.getElementById('modalInput');

            modalTitle.textContent = title;
            modalInput.placeholder = placeholder;
            modalInput.value = defaultValue;
            modal.style.display = 'block';
            modalInput.focus();

            modalCallback = callback;
        }

        function closeModal() {
            document.getElementById('inputModal').style.display = 'none';
            modalCallback = null;
        }

        function submitModal() {
            const input = document.getElementById('modalInput');
            const value = input.value.trim();

            if (value && modalCallback) {
                modalCallback(value);
            }
            closeModal();
        }

        function showConfirm(title, message, callback) {
            const modal = document.getElementById('confirmModal');
            const confirmTitle = document.getElementById('confirmTitle');
            const confirmMessage = document.getElementById('confirmMessage');

            confirmTitle.textContent = title;
            confirmMessage.textContent = message;
            modal.style.display = 'block';

            confirmCallback = callback;
        }

        function closeConfirmModal() {
            document.getElementById('confirmModal').style.display = 'none';
            confirmCallback = null;
        }

        function confirmAction() {
            if (confirmCallback) {
                confirmCallback();
            }
            closeConfirmModal();
        }

        function showAlert(message) {
            showConfirm('Notice', message, () => {});
        }

        // Handle Enter key in modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && document.getElementById('inputModal').style.display === 'block') {
                submitModal();
            }
            if (e.key === 'Escape') {
                closeModal();
                closeConfirmModal();
            }
        });

        // Close modal when clicking outside
        window.onclick = (e) => {
            const inputModal = document.getElementById('inputModal');
            const confirmModal = document.getElementById('confirmModal');
            if (e.target === inputModal) {
                closeModal();
            }
            if (e.target === confirmModal) {
                closeConfirmModal();
            }
        };

        function addNode() {
            if (!selectedNode) {
                showAlert('Please select a parent node first');
                return;
            }
            addChild(selectedNode);
        }

        function addChild(node) {
            showModal('Add New Node', 'Enter node name...', '', (name) => {
                if (name) {
                    const newNode = new Node(name);
                    if (node.isLeaf) {
                        node.isLeaf = false;
                        node.status = 'new';
                    }
                    node.children.push(newNode);
                    updateParentStatuses(mindMap);
                    renderMindMap();
                }
            });
        }

        function renameNode() {
            if (!selectedNode) {
                showAlert('Please select a node to rename');
                return;
            }
            showModal('Rename Node', 'Enter new node name...', selectedNode.name, (newName) => {
                if (newName && newName.trim()) {
                    selectedNode.name = newName.trim();
                    renderMindMap();
                } else {
                    showAlert('Node name cannot be empty');
                }
            });
        }

        function removeNode() {
            if (!selectedNode) {
                showAlert('Please select a node to remove');
                return;
            }
            if (selectedNode === mindMap) {
                showAlert('Cannot remove the root node');
                return;
            }
            removeChild(selectedNode);
        }

        function removeChild(node) {
            showConfirm(
                'Confirm Removal',
                `Are you sure you want to remove "${node.name}" and all its children?`,
                () => {
                    function removeFromParent(parent) {
                        const index = parent.children.indexOf(node);
                        if (index !== -1) {
                            parent.children.splice(index, 1);
                            if (parent.children.length === 0) {
                                parent.isLeaf = true;
                                parent.status = 'new';
                            }
                            updateParentStatuses(mindMap);
                            selectedNode = null;
                            renderMindMap();
                        } else {
                            parent.children.forEach(child => removeFromParent(child));
                        }
                    }
                    removeFromParent(mindMap);
                }
            );
        }

        function exportToJson() {
            const json = JSON.stringify(mindMap, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'mindmap.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function convertToNode(obj) {
            const node = new Node(
                obj.name,
                obj.isLeaf,
                obj.children ? obj.children.map(convertToNode) : [],
                obj.collapsed || false
            );
            node.status = obj.status || 'new';
            return node;
        }

        function importFromJson() {
            const file = document.getElementById('importFile').files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const jsonData = JSON.parse(e.target.result);
                    mindMap = convertToNode(jsonData);
                    updateParentStatuses(mindMap);
                    selectedNode = null;
                    renderMindMap();
                };
                reader.readAsText(file);
            }
        }

        window.onload = function() {
            if (!document.getElementById('mindmap')) {
                console.error('Mindmap container not found on page load');
                return;
            }
            renderMindMap(mindMap, document.getElementById('mindmap'), 0);
        };
    </script>
</body>
</html>